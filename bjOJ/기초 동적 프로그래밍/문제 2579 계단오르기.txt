문제 2579 계단오르기

점진적으로 오르는 것
dp 사용

여기서 조건 

dp[1] 
0+1

dp[2] 
0+1+2
0+2

dp[3]= 
0+1+3
0+2+3

dp[4]= 
0+1+2+4
0+1+3+4
0+2+4
0+2+3+4

dp[5]=
0+1+2+4+5
0+1+3+5
0+2+3+5
0+2+4+5

dp[6]=
0+1+2+4+5+6
0+1+2+4+6
0+1+3+5+6
0+2+3+5+6


+답 
*Top-Down 방식
(큰문제부터 작은 문제로 들어가는 방식)
재귀호출은 통해 작은 문제로 쪼개서 들어가는 것

*Bottom-UP 방식
-작은 문제부터 풀어가며 전체 문제를 풀어가는 방식
(대개 반복문을 통해 구현 된다)

메모이제이션을 할때 이전에 계산한 값을 저장하는데
여기서 연속으로 3계단은 밟을 수없다는 점을 유의해야 함

static int find(int N) {
 
	if(dp[N] == null) {
		dp[N] = Math.max(find(N - 2), find(N - 3) + arr[N - 1]) + arr[N];
	}
		
	return dp[N];
}

여기서 보면 N-1일때는 재귀 호출 하지 않는다
->메모이제이션이 아닐때가지 호출하기 때문이다
(dp[N]이  null이 아닐때까지)


ex)
N=5값을 넣었다고 가정하면 dp[4]가 메모이제이션이 되었다고 할때 이전 계단을 밟은 상태인지 알수 없다

따라서 연속되 블럭의 경우의 수는 재귀호출이 아니라 이미 입력받은 배열의 값을 더해주어야 한다


->두 계단 전의 경우 (N-2) 직전계단(N-1)을 밟고 

그 이전에는 두 계단 이전의 경우(N-3)에서 연속되지 않은 위치인 N-2와 N-3에 대해서만 재귀 호출을 해주어야 한다


*Bottom-Up

for (int i = 3; i <= N; i++) {
	DP[i] = Math.max(DP[i - 2] , DP[i - 3] + arr[i - 1]) + arr[i];
}



내가 이해가 안되는 부분
dp[i-3] 부분에 접근한다고 해도 i-3에서도 연속으로 오는 경우 있지 않냐는 것이지

=>그래서 재귀로 i-5로 들어가고 i-5는 i-7로 들어가는 것임 

내가 중요하게 놓치점:::::::::
기존에 계산된 dp[x]을 값을 가지고 진행하는 것이 아니라
새로운 dp[N]으로 가지로 점차적으로 메모이제이션을 하는 것임

 
 i   i-1   i-2   i-3

i에 접근 하는 방법은
1.   i-2에서 2칸 이동	
(이전에 2칸으로 접근)

2.   i-3에서 2칸 이동하여 i-1로 가는 것	그리고 한칸 이동 
(연속으로 한 칸씩 접근)

1,2번중 최대값을 가지고 감

-->애초에 dp 배열에서 접근 전제를 연속으로 3칸 금지로 함
그렇게 메모이제이션을 함







































